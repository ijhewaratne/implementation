# energy_tools.py
import json
import os
import subprocess
import sys
import yaml
from adk.api.tool import tool
import pandas as pd
import glob
import re
import geopandas as gpd
import matplotlib.pyplot as plt
from shapely.ops import nearest_points
from shapely.geometry import LineString


# --- NEW: Visualization Tool ---
@tool
def create_network_visualization(street_name: str, scenario_type: str) -> str:
    """
    Creates and saves a PNG map visualizing the energy network for a given street.
    This tool should be called after the main simulation pipeline has run, as it
    relies on the output files from that pipeline.

    Args:
        street_name: The name of the street to visualize.
        scenario_type: The scenario type ('DH' or 'HP') to label the map correctly.

    Returns:
        A string message indicating success or failure and the path to the saved image.
    """
    print(f"TOOL: Creating visualization for '{street_name}' ({scenario_type})...")

    # Define file paths for the data generated by the main pipeline
    results_dir = "results_test/"
    buildings_path = os.path.join(results_dir, "buildings_prepared.geojson")
    streets_path = os.path.join(results_dir, "streets.geojson")
    output_image_path = os.path.join(
        results_dir, f"network_map_{street_name.replace(' ', '_')}_{scenario_type}.png"
    )

    try:
        # Load the necessary data files
        if not os.path.exists(buildings_path) or not os.path.exists(streets_path):
            return f"Error: Cannot create visualization. Required data files not found in '{results_dir}'."

        buildings_gdf = gpd.read_file(buildings_path)
        street_gdf = gpd.read_file(streets_path)

        # Ensure both layers are in the same projected CRS for accurate plotting
        utm_crs = buildings_gdf.estimate_utm_crs()
        buildings_proj = buildings_gdf.to_crs(utm_crs)
        street_proj = street_gdf.to_crs(utm_crs)

        # Calculate connection lines from buildings to the street
        street_line = street_proj.geometry.unary_union
        connection_lines = []
        for _, building in buildings_proj.iterrows():
            p_building, p_street = nearest_points(building.geometry, street_line)
            connection_lines.append(LineString([p_building, p_street]))
        connections_gdf = gpd.GeoDataFrame(geometry=connection_lines, crs=utm_crs)

        # --- Plotting Logic (from your graph2.py) ---
        fig, ax = plt.subplots(figsize=(12, 12))

        # Plot layers from bottom to top
        street_proj.plot(ax=ax, color="black", linewidth=3, label="Main Street")
        buildings_proj.plot(ax=ax, color="lightgrey", edgecolor="black")
        connections_gdf.plot(ax=ax, color="red", linewidth=1.5, label="Service Connections")

        ax.set_title(f"Energy Network for {street_name} ({scenario_type.upper()})")
        ax.set_axis_off()
        ax.set_aspect("equal", adjustable="box")
        plt.legend()
        plt.tight_layout()

        # Save the figure to a file
        plt.savefig(output_image_path, dpi=300)
        plt.close(fig)  # Close the figure to free up memory

        print(f"TOOL: Visualization saved to {output_image_path}")
        return f"Visualization created successfully. Map saved to: {output_image_path}"

    except Exception as e:
        import traceback

        return f"Error creating visualization: {traceback.format_exc()}"


# --- High-level tools now include the visualization step ---


@tool
def run_complete_dh_analysis(street_name: str) -> str:
    """Runs a complete DH analysis, generates an LLM report, and creates a visualization."""
    print(f"HIGH-LEVEL TOOL: Running complete DH analysis for '{street_name}'...")

    # Step 1: Get building IDs
    building_ids = get_building_ids_for_street.func(street_name)
    if not isinstance(building_ids, list) or not building_ids:
        return f"Could not find any buildings for '{street_name}'. Please try another street."

    # Step 2: Run simulation pipeline
    sim_result = run_simulation_pipeline.func(building_ids, "DH")
    if sim_result["status"] == "error":
        return f"DH simulation failed: {sim_result['message']}"

    # Step 3: Analyze results
    analysis_result = analyze_kpi_report.func(sim_result["kpi_path"])

    # --- NEW Step 4: Create Visualization ---
    print("\n--- Generating Visualization Map ---")
    viz_result = create_network_visualization.func(street_name, "DH")

    return f"{analysis_result}\n\n{viz_result}"


@tool
def run_complete_hp_analysis(street_name: str) -> str:
    """Runs a complete HP analysis, generates an LLM report, and creates a visualization."""
    print(f"HIGH-LEVEL TOOL: Running complete HP analysis for '{street_name}'...")

    # Step 1: Get building IDs
    building_ids = get_building_ids_for_street.func(street_name)
    if not isinstance(building_ids, list) or not building_ids:
        return f"Could not find any buildings for '{street_name}'. Please try another street."

    # Step 2: Run simulation pipeline
    sim_result = run_simulation_pipeline.func(building_ids, "HP")
    if sim_result["status"] == "error":
        return f"HP simulation failed: {sim_result['message']}"

    # Step 3: Analyze results
    analysis_result = analyze_kpi_report.func(sim_result["kpi_path"])

    # --- NEW Step 4: Create Visualization ---
    print("\n--- Generating Visualization Map ---")
    viz_result = create_network_visualization.func(street_name, "HP")

    return f"{analysis_result}\n\n{viz_result}"


# --- Other tools remain the same ---


@tool
def get_all_street_names() -> list[str]:
    """Returns a list of all available street names in the dataset."""
    full_data_geojson = "data/geojson/hausumringe_mit_adressenV3.geojson"
    try:
        with open(full_data_geojson, "r", encoding="utf-8") as f:
            data = json.load(f)
    except FileNotFoundError:
        return ["Error: Main data file not found."]
    street_names = {
        adr.get("str").strip()
        for feat in data["features"]
        for adr in feat.get("adressen", [])
        if adr.get("str")
    }
    return sorted(list(street_names))


@tool
def list_available_results() -> str:
    """Lists all available result files and their locations."""
    result_dir = "results_test"
    if not os.path.exists(result_dir):
        return "No results directory found."
    files = glob.glob(f"{result_dir}/**", recursive=True)
    if not files:
        return "The results directory is empty."
    output = "=== AVAILABLE RESULT FILES ===\n" + "\n".join(
        [f"â€¢ {f}" for f in sorted(files) if os.path.isfile(f)]
    )
    return output


@tool
def get_building_ids_for_street(street_name: str) -> list[str]:
    """Finds and returns a list of building IDs located on a specific street."""
    full_data_geojson = "data/geojson/hausumringe_mit_adressenV3.geojson"
    try:
        with open(full_data_geojson, "r", encoding="utf-8") as f:
            data = json.load(f)
    except FileNotFoundError:
        return ["Error: Main data file not found."]
    street_set = {street_name.strip().lower()}
    selected_ids = {
        feat.get("gebaeude", {}).get("oi")
        for feat in data["features"]
        for adr in feat.get("adressen", [])
        if adr.get("str")
        and adr.get("str").strip().lower() in street_set
        and feat.get("gebaeude", {}).get("oi")
    }
    return list(selected_ids)


@tool
def run_simulation_pipeline(building_ids: list[str], scenario_type: str) -> dict:
    """Runs the energy simulation pipeline. Returns a dictionary with status and KPI path."""
    base_config_path = "run_all_test.yaml"
    dynamic_config_path = f"config_{scenario_type}_run.yaml"
    try:
        with open(base_config_path, "r") as f:
            config_data = yaml.safe_load(f)
    except FileNotFoundError:
        return {"status": "error", "message": f"Base config not found at '{base_config_path}'"}
    config_data["selected_buildings"] = building_ids
    config_data["scenario_config_file"] = f"scenarios_{scenario_type.lower()}.yaml"
    with open(dynamic_config_path, "w") as f:
        yaml.dump(config_data, f, sort_keys=False)
    try:
        subprocess.run(
            [sys.executable, "main.py", "--config", dynamic_config_path],
            check=True,
            capture_output=True,
            text=True,
        )
        kpi_path = os.path.join(config_data.get("output_dir", "results_test/"), "scenario_kpis.csv")
        return {"status": "success", "kpi_path": kpi_path}
    except subprocess.CalledProcessError as e:
        return {"status": "error", "message": f"Pipeline failed: {e.stderr}"}


@tool
def analyze_kpi_report(kpi_report_path: str, comparison_prompt: str = "") -> str:
    """Analyzes a KPI report file using an LLM."""
    if not os.path.exists(kpi_report_path):
        return f"Error: KPI report not found at '{kpi_report_path}'"
    try:
        scenario_file = "scenarios_dh.yaml"
        if "hp" in kpi_report_path.lower() or "comparison" in kpi_report_path.lower():
            scenario_file = "scenarios_hp.yaml"  # Needs better logic for comparison
        output_report_file = "results_test/llm_final_report.md"
        with open("run_all_test.yaml", "r") as f:
            main_config = yaml.safe_load(f)
        command = [
            sys.executable,
            "src/llm_reporter.py",
            "--kpis",
            kpi_report_path,
            "--scenarios",
            scenario_file,
            "--output",
            output_report_file,
            "--model",
            main_config.get("llm_model", "gpt-4o"),
            "--api_key",
            main_config.get("openai_api_key", ""),
        ]
        if comparison_prompt:
            command.extend(["--config", json.dumps({"extra_prompt": comparison_prompt})])
        subprocess.run(command, check=True, capture_output=True, text=True)
        with open(output_report_file, "r", encoding="utf-8") as f:
            return f"KPI analysis complete. Here is the summary:\n\n{f.read()}"
    except Exception as e:
        return f"Error analyzing KPI report: {str(e)}"


@tool
def compare_scenarios(street_name: str) -> str:
    """Runs both DH and HP scenarios for a street, then generates a comparative analysis."""
    building_ids = get_building_ids_for_street.func(street_name)
    if not isinstance(building_ids, list) or not building_ids:
        return f"Could not find buildings for '{street_name}'."
    dh_result = run_simulation_pipeline.func(building_ids, "DH")
    if dh_result["status"] == "error":
        return f"Failed to run DH scenario: {dh_result['message']}"
    hp_result = run_simulation_pipeline.func(building_ids, "HP")
    if hp_result["status"] == "error":
        return f"Failed to run HP scenario: {hp_result['message']}"
    dh_kpis = pd.read_csv(dh_result["kpi_path"])
    dh_kpis["scenario_type"] = "DH"
    hp_kpis = pd.read_csv(hp_result["kpi_path"])
    hp_kpis["scenario_type"] = "HP"
    combined_kpis = pd.concat([dh_kpis, hp_kpis], ignore_index=True)
    comparison_kpi_path = "results_test/kpi_comparison.csv"
    combined_kpis.to_csv(comparison_kpi_path, index=False)
    comparison_prompt = "The user wants a direct comparison between the DH and HP scenarios. Please highlight the key trade-offs in terms of cost (LCoH), emissions (CO2), and any other significant differences. Conclude with a clear recommendation based on the data."
    return analyze_kpi_report.func(comparison_kpi_path, comparison_prompt=comparison_prompt)
